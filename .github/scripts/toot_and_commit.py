#!/usr/bin/env python3
"""
Generated by the github copilot agent, but heavily modified and corrected by me
"""

"""
What this script does: 
Finds published posts in _posts/, post a toot for those missing comment_id, write the comment_id back and commit.


This is compatible to jekyll, regarding publishing it considers the `publish` and `published` flag and checks the date whether it is already published
(YAML has precedence over filename). 
NOTE: This will generate wrong links, if you wrote one of the predefined permalinks schemes into the frontmatter (or changed the default). Only the default scheme is currently supported.


Environment variables:
  MASTODON_TOKEN - access token for Mastodon
  GITHUB_TOKEN - token with repo write permissions (provided by Actions)

Furthermore in _config.yml:
url for generating links to the blog
mastodon: 
    - username: xyz
      instance: abc.com

      The mastodon username and instance


This script edits files in-place and commits changes using git.
"""
import os
import re
import sys
import yaml
import requests
from datetime import datetime, timezone
from dateutil import parser as date_parser
from pathlib import Path
import subprocess
import logging

POSTS_DIR = Path("_posts")


def parse_front_matter(text):
    m = re.match(r"^---\n(.*?)\n---\n(.*)$", text, re.S)
    if not m:
        logging.warning(f"Frontmatter regex failed on a post: {text}")
        return None, text
    fm_text, body = m.group(1), m.group(2)
    data = yaml.safe_load(fm_text) or {}
    logging.debug(data)
    return data, body


def build_content(fm, body):
    fm_text = yaml.safe_dump(fm, sort_keys=False).rstrip() + "\n"
    return "---\n" + fm_text + "---\n" + (body.lstrip())


def get_date(fm, filename):
    date = fm.get("date")
    if date is None:
        date = "-".join(filename.split("-")[:3])
    # Crashes if date does not exist or is invalid
    d = date_parser.parse(str(date))
    if d.tzinfo is None:
        d = d.replace(tzinfo=timezone.utc)
    return d
    

def is_published(fm, filename):
    pub = fm.get("publish") or fm.get("published") or fm.get("published",
                                                    None)
    if isinstance(pub, bool) and not pub:
        return False
    # allow publish: true or published: true; if absent, consider published if date <= now
    d = get_date(fm, filename)
    if d:
        return d <= datetime.now(timezone.utc)
    
    return True


def toot_post(instance, token, content, in_reply_to_id=None):
    url = f"https://{instance}/api/v1/statuses"
    data = {"status": content, "visibility": "public"}
    if in_reply_to_id:
        data["in_reply_to_id"] = in_reply_to_id
    headers = {"Authorization": f"Bearer {token}"}
    r = requests.post(url, data=data, headers=headers, timeout=30)
    logging.debug(data, headers)
    r.raise_for_status() # Throw exception if this did not work
    return r.json()

def main():
    token = os.getenv("MASTODON_TOKEN")

    with open("_config.yml") as file:
        config = yaml.safe_load(file.read())
    instance = config.get("mastodon")[0]["instance"]
    if not instance or not token:
        logging.error("MASTODON_TOKEN must be set in github actions env and the mastodon block (see at the beginning of this file) configured in _config.yml")
        sys.exit(1)

    if not POSTS_DIR.exists():
        logging.error(f"Posts dir {POSTS_DIR} not found")
        sys.exit(1)

    changed_files = []

    for path in sorted(POSTS_DIR.iterdir()):
        if not path.is_file():
            logging.debug("A")
            continue
        text = path.read_text(encoding="utf-8")
        fm, body = parse_front_matter(text)
        if fm is None:
            logging.debug("B")
            continue
        if not is_published(fm, path.name):
            logging.debug("C")
            continue
        if fm.get("comment_id"):
            logging.debug("D")
            continue
        # check file has correct naming scheme

        logging.debug(f"Current filename: {path.name}")

        # prepare toot content: use title and permalink if present
        title = fm.get("title") or path.stem 
        # Link schemas are listed here: https://mademistakes.com/mastering-jekyll/how-to-link/
        # /:categories/:year/:month/:day/:title:output_ext

        if type(fm.get("categories")) == list:
            categories = "/".join(fm.get("categories"))
        else:
            categories = fm.get("categories")
        date = get_date(fm, path.name)
        if date is False:
            raise Exception("Could not parse Date")
        
        blog_url = config.get("url")
        url = fm.get("permalink") or f"{blog_url}/{categories}/{str(date.year)}/{str(date.day)}/{path.name.split(".")[-2]}.html"
        toot = f"""Read my new post {title}:
{url}

To comment on it, please just answer to this toot. The toots will be loaded underneath the article.

Lies meinen neuen Blogpost (link oberhalb)
Zum kommentieren, einfach unter diesem Toot kommentieren, die toots landen dann unter dem Artikel.
"""

        logging.info(f"Tooting for {path.name}: {toot}")
        try:
            res = toot_post(instance, token, toot) 
        except Exception as e:
            logging.error(f"Failed to toot {path}: {e}")
            continue

        comment_id = res.get("id")
        if not comment_id:
            logging.error(f"No id returned for {path}")
            break

        fm["comment_id"] = str(comment_id)
        new_content = build_content(fm, body)
        path.write_text(new_content, encoding="utf-8")
        changed_files.append(str(path))

if __name__ == "__main__":
    main()
